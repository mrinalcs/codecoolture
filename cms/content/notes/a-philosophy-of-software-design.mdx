---
date: "2019-04-11"
language: "Espa√±ol"
spoiler:
  "Un libro sobre dise√±o de software con un enfoque pr√°ctico y alejado de
  dogmatismos"
title: "üìö A Philosophy of Software Design"
url: "/notes/a-philosophy-of-software-design"
published: true
collections:
  - books
---

# A Philosophy of Software Design

Durante las √∫ltimas semanas he estado leyendo este maravilloso libro escrito por
John Ousterhout y me gustar√≠a compartir algunas conclusiones que he podido
extraer tras su lectura.

Lo primero, es que el libro me ha parecido un contrapunto muy interesante a
[_Clean Code_](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882).
B√°sicamente, ambos presentan estrategias para reducir la complejidad en el
dise√±o, desarrollo y mantenimiento de software (y la complejidad es un t√©rmino
sobre el que se discute largo y tendido en
[_A Philosophy of Software Design_](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201))
pero lo hacen, bajo mi punto de vista, desde dos √≥pticas diferentes.

Robert C. Martin (y mucha de la literatura que hay por ah√≠ fuera) pone el foco
especialmente en **reglas** y **principios**: tama√±o de las entidades
(¬°funciones de menos de 10 l√≠neas!), el n√∫mero de responsabilidades de una
abstracci√≥n, c√≥digo sobre documentaci√≥n, evitar duplicidades, etc. Sin embargo,
en _A Philosophy of Software Design_ nos encontramos un par de cap√≠tulos
dedicados en exclusiva al ‚Äúarte‚Äù de escribir buenos comentarios y a las ventajas
de invertir tiempo en expresar, a trav√©s de los mismos, aspectos relacionados
con el dise√±o de software que son pr√°cticamente imposibles de describir
utilizando √∫nicamente c√≥digo (por ejemplo, el conocimiento del dominio que nos
lleva a aplicar ciertos patrones o arquitecturas, _workarounds_ para lidiar con
_known issues_, etc).

De todos, el cap√≠tulo 10: _Define Errors Out Of Existence_, me ha parecido una
delicia, y creo que introduce conceptos muy interesantes para lidiar con los
casos esquina y errores de cualquier aplicaci√≥n.

Del mismo modo, algunos pasajes hablando sobre la ventaja de definir
abstracciones ‚Äúprofundas‚Äù (_deep_) en lugar de ‚Äúplanas‚Äù (_shallow_) ilustran
bastante bien los problemas de llevar t√©cnicas de _Clean Code_ al extremo, sin
aplicar un buen criterio.

Creo que la lectura de este libro me ha servido para adoptar un enfoque m√°s
pragm√°tico a la hora de escribir c√≥digo, alejado de dogmatismos y poniendo el
foco en lo que realmente importa, tratar de reducir al m√°ximo la complejidad de
nuestras soluciones (lo que impl√≠citamente nos llevar√° tambi√©n a la aplicaci√≥n
de buenas pr√°cticas de dise√±o).
