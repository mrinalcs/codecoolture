---
canonical: "https://octuweb.com/test-driven-front-end-development/"
date: "2020-11-01"
language: "Espa√±ol"
spoiler:
  "El desarrollo de cualquier aplicaci√≥n web es complejo. Hay un mont√≥n de
  funcionalidad por crear y, seguramente, poco tiempo ü§Ø Sin embargo, con la
  nueva generaci√≥n de herramientas front-end hay una metodolog√≠a que nos puede
  ayudar a no perder el foco y entregar valor de manera continua, con confianza."
title: "Test-driven front-end development"
url: "/blog/test-driven-front-end-development"
published: true
collections:
  - react
  - tdd
---

# Test-driven front-end development

> Este art√≠culo fue publicado originalmente en la edici√≥n de 2020 de
> [Octuweb](https://octuweb.com/test-driven-front-end-development/).

En la edici√≥n de 2018 **Cristina Ponce** public√≥
[Testing en el front](https://octuweb.com/testing-front/), una gu√≠a sobre los
diferentes tipos de pruebas que podemos realizar en aplicaciones front-end.
Apoy√°ndonos en ese art√≠culo, vamos a hablar aqu√≠ de c√≥mo aprovechar la nueva
generaci√≥n de herramientas para alcanzar flujos de desarrollo que, hasta hace
solo unos a√±os, no eran (tan) f√°cilmente aplicables en este contexto:
**Test-Driven Development** (o **TDD**).

## Pero primero, ¬øqu√© es TDD?

Test-Driven Development es una metodolog√≠a que se basa en aplicar peque√±os
ciclos de desarrollo con el objetivo de resolver casos de prueba. De manera m√°s
concreta, lo podemos definir en 3 pasos:

1. Codificar una prueba que defina el nuevo comportamiento que queremos a√±adir a
   nuestro sistema
2. Escribir la menor cantidad de c√≥digo posible que nos permita hacer pasar el
   test anterior
3. Mejorar el c√≥digo anterior utilizando las pruebas como red de seguridad
   (a.k.a _refactoring_)

En TDD cl√°sico, lo habitual es comenzar por las entidades m√°s internas de
nuestro sistema para ir construyendo capas una encima de otra hasta terminar de
implementar la funcionalidad. En front-end sin embargo, y con las herramientas
actuales, lo m√°s natural es utilizar una variaci√≥n denominada **ATDD**
(inspirada en **Outside-in**, un enfoque de TDD que se origin√≥ en la comunidad
de eXtreme Programming de Londres), donde se empieza creando un primer test en
la capa m√°s externa del sistema (en este caso, la interfaz o un componente) para
ir construyendo desde ah√≠ el resto de la funcionalidad.

## Escribiendo nuestro primer test

En su sentido m√°s estricto, TDD es una herramienta de desarrollo (un flujo de
trabajo, una metodolog√≠a) y no tiene que verse como un instrumento de calidad
(entendiendo esta como la disciplina para el control de defectos). Por tanto, su
objetivo es ayudar a las programadoras a entregar valor lo antes posible, con
confianza. En ATDD, por ejemplo, el primer test nos tiene que permitir poner el
foco en el problema que vamos a resolver y servirnos como gu√≠a durante el
desarrollo de la funcionalidad. Lo habitual es intentar reflejar en este primer
test los criterios de aceptaci√≥n que perseguimos cumplir con la historia de
usuario en curso.

Por ejemplo, supongamos que estamos trabajando en el front-end para la web de
una editorial de libros y queremos a√±adir una p√°gina de contacto:

> Es posible acceder a una p√°gina de contacto para, indicando email, asunto y
> mensaje, ponerse en contacto con la editorial. Una vez completada la
> operaci√≥n, se realizar√° una redirecci√≥n a una p√°gina de √©xito con un mensaje
> que indique que todo ha ido bien.
>
> Hay disponible un endpoint `/api/contact` que completa la operaci√≥n en el
> back-end.

Utilizando [**Cypress**](https://www.cypress.io/), podemos trasladar esta
descripci√≥n a una prueba de alto nivel como la siguiente:

```tsx
// Location: cypress/integration/sendContactMessage.test.ts

context("sendContactMessage", () => {
  specify("A user can send a contact message", () => {
    // Setup
    cy.server();
    cy.route2("/api/contact", { statusCode: 200 });

    // Act
    cy.visit("/contact");
    cy.findByLabelText(/tu email/i).type("hola@codecoolture.com");
    cy.findByLabelText(/asunto/i).type("Informaci√≥n sobre pr√≥ximos libros");
    cy.findByLabelText(/mensaje/i).type(
      "Hola, me gustar√≠a obtener m√°s informaci√≥n sobre pr√≥ximos libros.",
    );
    cy.findByText(/enviar/i).click();

    // Assert
    cy.url().should("eql", Cypress.config().baseUrl + "/contact/success");
    cy.findByText(/tu mensaje ha sido enviado con √©xito/i).should("exist");
  });
});
```

La prueba anterior codifica el escenario de aceptaci√≥n b√°sico: primero, hacemos
que Cypress simule la respuesta al endpoint `/api/contact` para indicar que todo
ha ido bien (devolver√° un c√≥digo `200`), y despu√©s interactuamos con la
aplicaci√≥n para ir a la p√°gina de contacto y completar el formulario. Por
√∫ltimo, validamos que se ha llevado al usuario a la p√°gina de √©xito tras enviar
el formulario.

> Ahora que hemos visto un ejemplo, seguramente nos sea m√°s sencillo explicar
> qu√© es Cypress: un framework de testing para construir pruebas de aceptaci√≥n
> sobre un navegador, utilizando JavaScript.

En el ejemplo anterior, la prueba se ejecutar√° sobre nuestra propia aplicaci√≥n.
En este caso, **como todav√≠a no hemos escrito c√≥digo de producci√≥n, lo que
esperamos es que el test falle**. Es ahora cuando tenemos que escribir la m√≠nima
cantidad posible de c√≥digo para que este test pueda pasar.

```tsx
// Location: pages/contact.tsx

export default function Contact() {
  return (
    <main>
      <Formik
        initialValues={{ email: "", subject: "", message: "" }}
        onSubmit={async ({ email, subject, message }) => {
          const response = await fetch("/api/contact", {
            body: JSON.stringify({ email, subject, message }),
            headers: { "content-type": "application/json" },
            method: "post",
          });

          if (response.ok) {
            window.location.href = "/contact/success";
          }
        }}
      >
        {() => {
          return (
            <Form>
              <label>
                Tu email <Field id="email" name="email" />
              </label>

              <label>
                Asunto <Field name="subject" />
              </label>

              <label>
                Mensaje <Field name="message" />
              </label>

              <button type="submit">Enviar</button>
            </Form>
          );
        }}
      </Formik>
    </main>
  );
}
```

```tsx
// Location: pages/contact/success.tsx

export default function ContactSuccess() {
  return <p>¬°Enhorabuena! Tu mensaje ha sido enviado con √©xito</p>;
}
```

Obviando algunos detalles de implementaci√≥n (como el uso de
[Formik](https://formik.org/) para el formulario), los dos fragmentos de c√≥digo
anteriores muestran una posible implementaci√≥n (b√°sica pero funcional) que sirve
para hacer pasar nuestro primer test de aceptaci√≥n. En este punto, podemos
a√±adir CSS a nuestra nueva p√°gina o extraer comportamientos a otro tipo de
entidades (por ejemplo, mover la operaci√≥n de `onSubmit` a un servicio). Si
nuestro test sigue en verde al completar los cambios, tendremos la certeza de
que no hemos roto nada ‚úÖ

## Aplicando ciclos de desarrollo m√°s peque√±os

Aunque Cypress es un magn√≠fico framework de testing, las pruebas de tan alto
nivel suelen venir con algunos compromisos: es dif√≠cil poder ejercitar todos los
caminos de ejecuci√≥n posibles y son lentas. Recordad que con TDD estamos
buscando mejorar nuestra productividad por lo que **necesitamos que los ciclos
de feedback sean lo m√°s cortos posibles**. Para ello, mi consejo es utilizar
pruebas de aceptaci√≥n para cubrir el _happy path_ de la funcionalidad (y quiz√°s
alg√∫n escenario de error clave) y despu√©s iterar en ciclos de desarrollo m√°s
peque√±os facilitados por pruebas de una granularidad m√°s baja (en front-end,
podr√≠amos entenderlas como h√≠bridos de integraci√≥n + unitaria, centradas en
componentes).

Si volvemos al ejemplo anterior, seguramente hay ciertas reglas de experiencia
de usuario que queramos validar sobre el formulario de contacto: que no se pueda
completar la operaci√≥n sin un email de remite o sin el cuerpo del mensaje, que
aparezcan correctamente los mensajes de error, que los campos permitan
√∫nicamente ciertos patrones, etc. Aunque estas pruebas se podr√≠an hacer tambi√©n
utilizando Cypress, su latencia es a menudo lo suficientemente grande como para
preferir moverlos a tests de m√°s bajo nivel (por lo general, m√°s r√°pidos).

Para hacer pruebas de componentes (en React, aunque las mismas herramientas
est√°n disponibles en otros frameworks como Vue o Angular) mi consejo es utilizar
[**Testing Library**](https://testing-library.com/) en conjunci√≥n con
[**Jest**](https://jestjs.io/). Por ejemplo, vamos a a√±adir un nuevo
comportamiento a nuestra p√°gina de Contacto, aunque esta vez iterando en un
nivel de abstracci√≥n m√°s bajo:

> El formulario s√≥lo debe enviarse si contiene un email de remite y un mensaje.

```tsx
// Location: components/ContactForm.test.tsx

describe("ContactForm", () => {
  it("does not submit the form if some required fields are missing", async () => {
    // Setup
    const spy = jest.fn();
    render(<ContactForm onSubmit={spy} />);

    // Act
    await user.type(
      screen.getByLabelText(/asunto/i),
      "Informaci√≥n pr√≥ximos libros",
    );

    user.click(screen.getByText(/enviar/i));

    // Assert
    await expect(
      screen.findAllByText("Este campo es obligatorio."),
    ).resolves.toHaveLength(2);

    await waitFor(() => expect(spy).not.toHaveBeenCalled());
  });
});
```

El test anterior codifica el nuevo comportamiento que queremos validar. Ver√©is
que, en un primer vistazo, la apariencia del test es similar al primero que
creamos utilizando Cypress. La √∫nica diferencia es que aqu√≠ se prueba el
componente de manera aislada en lugar de simular a un usuario real utilizando la
aplicaci√≥n. En Testing Library, no hay ning√∫n navegador ejecut√°ndose en
paralelo, como s√≠ ocurre con Cypress; as√≠, mientras el √∫ltimo que hemos escrito
podemos ejecutarlo en ~2 segundos, el primero necesita de ~22 segundos.

Cuando trabajamos a un nivel de granularidad m√°s bajo, nuestros tests pueden
afectar al dise√±o de nuestros componentes (por lo general, haci√©ndolos m√°s
sencillos de probar). En este caso, he decidido inyectar la funci√≥n que gestiona
el env√≠o del formulario para poder reemplazarla por un esp√≠a que me permita
validar que no se ha invocado cuando no deb√≠a (aunque tambi√©n podr√≠amos haber
espiado el m√≥dulo HTTP con [**nock**](https://github.com/nock/nock)). Este es
otro de los beneficios clave de TDD, ser capaces de ir definiendo el dise√±o de
nuestras interfaces a medida que escribimos las pruebas.

Como todos estos cambios no est√°n repercutiendo en cambios de comportamiento a
nivel de aceptaci√≥n, nuestro test de Cypress deber√≠a seguir pasando despu√©s de
cada modificaci√≥n, ayud√°ndonos de nuevo a garantizar que no hemos roto nada ‚úÖ.

Ahora, al igual que en el ejercicio anterior, tendr√≠amos que escribir la menor
cantidad de c√≥digo que sirva para hacer pasar este test.

> Pss! Pod√©is ver el ejemplo completo en
> [este repositorio de GitHub](https://github.com/codecoolture/octuweb-2020) üëÄ

## Conclusi√≥n

¬øQue conseguiremos aplicando un flujo similar al anterior? En la literatura de
TDD, estar√≠amos aplicando lo que se conoce como
[Outside-In development with Double Loop TDD](http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/)
o el proceso descrito en el libro
[Growing Object-Oriented Software, Guided by Tests](https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests).

Primero, arrancamos con un test de aceptaci√≥n (o del nivel de granularidad m√°s
alto que podamos) que nos ayudar√° a mantener el foco en la funcionalidad que
queremos resolver. En ocasiones, este test puede estar fallando durante varias
horas porque necesite de otros ciclos complementarios m√°s peque√±os que nos
ayuden avanzar (el ejemplo anterior era tan sencillo que no lo hemos
necesitado). Para esos ciclos complementarios es donde podemos hacer uso de
flujos como TDD cl√°sico (√∫til para avanzar en piezas de bajo nivel como
funciones, clases, servicios) y herramientas como Testing Library (para probar
los diversos componentes que construyan la interfaz) o _simplemente_ Jest (para
l√≥gica de negocio como controladores, funciones de utilidad, etc.).

## Otras referencias

- Adem√°s de los enlaces contenidos en el art√≠culo, pod√©is encontrar m√°s
  referencias a TDD en
  [esta p√°gina](https://www.notion.so/codecoolture/Public-References-50b1e927fe1641748f95610353e97b7f).
- Cypress tiene una secci√≥n de
  [mejores pr√°cticas](https://docs.cypress.io/guides/references/best-practices.html)
  con algunos consejos muy √∫tiles sobre c√≥mo escribir pruebas de aceptaci√≥n.
- [Kent C. Dodds](https://twitter.com/kentcdodds/) (creador de Testing Library)
  tiene bastantes art√≠culos relacionados con testing de aplicaciones front-end
  (desde TDD hasta diferentes estrategias de testing). Pod√©is encontrarlos en
  [su blog](https://kentcdodds.com/blog?q=testing).
